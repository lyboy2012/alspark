                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    [{"title":"flutter 之基础环境","date":"2019-11-07T14:44:02.000Z","url":"/alspark/2019/11/07/flutter-base/","content":"install flutter sdk flutter sdk 安装以mac 系统为例下载sdk压缩包 flutter_sdk_zip解压sdk zip包解压zip 包到指定目录，可以根据喜好选择目录，以下为本人目录设置环境变量检查 flutter 环境依赖     可以根据提示安装少的依赖    CocoaPods 是什么？也可以通过以下命令直接拉包（???咋感觉思路不太对，需要iOS 同学问问）iOS 环境依赖iOS 环境依赖于xcode 下载最新版本xcode(比较坑系统也需要升级到最新版本)   vs code 开发初体验安装flutter 插件shif+command+P输入flutter 安装reload windowshif+command+P验证flutter 环境依赖shif+command+P创建项目shif+command+P输入项目名称： 以下划线小写规则运行flutter 第一个项目vscode 选择个模拟器并启动fn+F5 启动debug 模式 到此位置第一个demo就完成了 生息自己补脑吧"},{"title":"vue 基础回顾-技术点之事件","date":"2019-10-31T09:21:03.000Z","url":"/alspark/2019/10/31/vue-base4/","content":"vue 事件说明v-on 指令监听 DOM 事件, 而且仅在当前ViewModel上;ViewModel 被销毁时，所有的事件处理器都会自动被删除事件修饰符按键修饰符    自定义按键修饰符别名(统一维护)自动匹配按键修饰符直接将 KeyboardEvent.key 共8个， 暴露的任意有效按键名转换为 kebab-case 来作为修饰符：注意 ie9 需要特殊处理；key 值中线，小写；    处理函数onPageDown仅在 $event.key === ‘PageDown’ 时被调用系统修饰符    .exact 修饰符exact： 翻译为准确的；控制由精确的系统修饰符组合触发的事件；点击同时其它按键一起按下触发；      鼠标按键修饰符  v-model 双向绑定指令指令在表单 &lt;input&gt; 及 &lt;textarea&gt; 元素上创建双向数据绑定;它会根据控件类型自动选取正确的方法来更新元素;会忽略所有表单元素的 value、checked、selected 特性的初始值,通过data值进行初始化；    输入法（如中文、日文、韩文等）组合文字过程中，不会更新data，如果需要更新需要用到input 事件  代码    是以下代码语法糖  .lazy默认 v-model 输入框的值与数据进行同步（除输入法组合文字时），只要有input事件就会立即更新；lazy 切换成onchange 事件.number .trim   number限定输入数字类型；trim自动过滤首位空格；"},{"title":"vue 基础回顾-技术点之组件","date":"2019-10-31T09:10:23.000Z","url":"/alspark/2019/10/31/vue-base3/","content":"组件注册方式  全局注册全局在注册之后可用在任何新创建的 Vue 根实例 (new Vue) 的模板中；在所有子组件中也是如此，也就是说这全局注册组件在各自内部也都可以相互使用；局部全局注册回导致webpack 打包在不使用也会打包；局部注册的组件在其子组件中使用；  Prop 验证  对应react PropTypesreactvue type 可以是下面原生构造器：构造函数：也可以是一个自定义构造器函数，使用 instanceof 检测。组件 data 必须是函数定义组件实际是创建个组件的构造器；注册组件是建立一个组件构造器的引用；使用组件才是真正创建组件实例；定义组件 data 必须是函数new Vue 实例传入是个值原理分析代码如下：组件组合（组件嵌套）父子组件关系： prop 向下传递(单向数据流)，事件向上传递 ；父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息；prop 向下传递，是单向数据流向，每次父组件更新时，子组件的所有 prop 都会更新为最新值，不应该在子组件内部改变 prop。说明：HTML 特性是不区分大小写的，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需转换为相对应的 kebab-case (短横线分隔式命名)；单向数据流两种特殊场景  (其实可以认为是一种)prop 初始值做为子组件data prop 初始值做为子组件加工后的数据(computed)单向数据流引起reRender讨论diff 在个框架 差别react: diff dom，但是不 diff 数据vue: diff 数据（其实不能叫 diff，而是通过对更改的劫持，自动获得了 diff），也      diff dom（其实可以不 diff，它这个机制，其实用不到 vdom）angular: diff 数据，但是不 diff domcycle: diff dom，但不 diff 数据数据与视图更新关系react: 数据变化之后，用户通过 setState 主动通知框架更新视图 ，通过shouldComponentUpdate PureComponent 来优化rerender；vue：数据变化之后，框架通过对原生对象和数组类型变更方法的劫持自动发现更新的部分，刷新视图，用户没有手动过程angular: 1.x 数据变化之后，通过 $digest 主动通知框架更新视图（框架劫持了大部分异步行为，自动做这个事情）2 以后版本，changeDetection 允许两种模式，自动和手动自动：基于 zone.js，原理与 1.x 的 $digest 相同手动：数据变化之后，用户手动调用 cd，通知框架更新视图另外，可以通过内置的 rxjs 的 observable，接管一切异步行为，并在订阅cyclejs: 数据本身就在 stream 中，订阅直达 vdom，用户没有手动过程说明：react hooks shouldComponentUpdate stackoverflow可以通过如下代码.sync 修饰符  （2.0 移除 2.3.0  再次引入）违背单向数据流，但用起来方便  sync的 prop 的值时，这个变化会同步到父组件中所绑定的值；    等同于  自定义事件  （子组件与父组件通信）      目的： 子组件通过事件给父组件发送消息，解决不违背单向数据流通讯问题vue 实例实现事件接口$on(eventName) 监听事件$emit(eventName) 触发事件说明：$on 和 $emit 并不是addEventListener 和 dispatchEvent 的别名父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件自定义组件的 v-model代码等同于下面语法糖完整示例：自定义组件的 v-model，来解决如单选框、复选框之类的输入类型等价"},{"title":"vue 基础回顾-技术点","date":"2019-10-31T06:10:05.000Z","url":"/alspark/2019/10/31/vue-base2/","content":"技术点Vue.set 与this.$set 区别Vue.set 设置实例创建之后添加的新的属性，（在data里未声明的属性）this.$set只能设置实例创建后存在的属性（在data里声明的属性）Vue.nextTick(callback)  回调函数在 DOM 更新完成后就会调用，类似与react setState 回调；计算属性(computed) 和 methods 差别  计算属性是基于它们的依赖进行缓存的,计算属性只有在它的相关依赖发生改变时才会重新求值,计算函数不会多次执行。    watch监听属性应用场景  当需要在数据变化时执行异步或开销较大的操作时；key-管理可复用的元素  官网说明         以下实例，不用key 相同元素会缓存placeholder  咋感觉是vue bug :(v-bind v-on 缩写  官网说明v-if  v-show 差别v-if dom 切换 ，v-show  display:none;v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。使用场景： 如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。v-if 与 v-for 优先级  v-for 的优先级比 v-if 更高;      以上代码仅渲染未完成的 todostodos 长度大于0执行v-forv-for 通过&lt;template&gt; 渲染多个子个元素  相当于react fragment 短语法　&lt;&gt;模版解析 is 作用  is目的：解决自定义组件中使用这些受限制的元素；  DOM 作为模板时 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt;、&lt;select&gt; 内元素有限制；  注意&lt;script type=”text/x-template”&gt;、.vue 组件、JavaScript 内联模板字符串、无此限制；问题代码：  修复代码  for循环 应用  在 &lt;ul&gt; 元素内只有 &lt;li&gt; 元素有效，要is=”todo-item”,避开一些潜在的浏览器解析 指令for 、bind、 on 错误  is 与 &lt;component&gt; 实现动态组件切换  keep-alive  切换组件避免组件重复渲染，保留在内存  "},{"title":"vue 基础回顾-基础概念","date":"2019-10-31T03:17:11.000Z","url":"/alspark/2019/10/31/vue-base/","content":"vue 基础知识生命周期 官网地址  组件  装可重用的代码  官网地址动态组件  实现动态组件切换  官网地址自定义指令  官网地址深入响应式原理  官网地址异步更新队列  官网地址计算属性和观察者  官网地址DOM-模板解析注意事项  官网地址事件修饰符  官网地址表单输入绑定 官网地址"},{"title":"hexo 环境搭建","date":"2019-10-31T01:56:09.000Z","url":"/alspark/2019/10/31/hexo-env/","content":"介绍 官网地址基本搭建流程installdeploy to github新建github 项目 如果项目名称自定 PRO_NAME，需要修改blog 目录下_config.yml开启github pagesgithub settings ==&gt; GitHub Pages source,选择master branch (也可选择其它分支做为发布分支);Your site is published at XXX ,XXX 域名就是公网可访问的地址；安装 hexo git 发布插件添加hexo 发布配置 发布注意: 如果有缓存 可以执行以下命令清除，并重新生成。install themes  hexo-theme-sukainstall项目根目录执行clone_config.yml 追加项目根目录_config.yml设置suka _config.yml 在目录安装suka依赖themes/suka 执行开发调试  hexo-browsersync 插件实现修改立即更新安装依赖追加BrowserSync 配置到_config.ymldraft 草稿草稿不publish，不会到_posts ，deploy 不会到线上。新建草稿文章推送到正式搜索配置在目录source下新增search.mdsearch.md 录入以下内容  修改项目根目录下_config.yml修改themes/suka/目录下_config.yml search link 地址如果上面提的PRO_NAME存在,就拼接上新增评论功能  思路：通过github gitalk 实现评论，gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件；  gittalk 需要先创建applications 通过applications 来使用GitHub提供的 OAuth 服务，来实现登授权   官网参考链接新建github applications新建地址配置 github applications 信息配置 themes/suka 下 _config.yml "}]